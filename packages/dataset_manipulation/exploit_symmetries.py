"""
Exploit symmetries in three variable polynomials to generate up to six
instances out of each existing one.

The task at hand consists in classify this features.
We will take advantage of the fact that we can change the target by
reordering the features.

This file will contain:
- features_to_canonical_ordering: a function able to reorder the features so
that the target becomes '1', this ordering is called the canonical order.
- give_all_symmetries: a function that given the canonical order returns the
reorderings for each of the possible targets '1','2',...,'6'.
"""
from itertools import permutations


def get_perms(variables):
    perms = [list(elem) for elem in permutations(variables)]
    return perms


def features_to_canonical_target(features, optimal_ordering, nvar=3):
    """
    Reorder the features for the target to be '1'.

    This is done by reordering the features according to the optimal variable
    ordering of the set of polynomials.
    """
    perms = get_perms(list(range(nvar)))
    best_variable_ordering = perms[optimal_ordering]
    nfeatures = len(features)
    split_features = [features[int(var*nfeatures/nvar):
                               int((var+1)*nfeatures/nvar)]
                      for var in range(nvar)]
    ordered_features = [split_features[best_variable_ordering[i]]
                        for i in range(nvar)]
    return ordered_features


def give_all_symmetries(features, optimal_ordering=0, nvar=3):
    """Reorder the features for all possible targets.
    Returns a list of of all symmetries, the first one
    corresponding to the optimal ordering"""
    perms = get_perms(list(range(nvar)))
    ordered_features = features_to_canonical_target(features,
                                                    optimal_ordering)
    all_symmetries = []
    for perm in perms:
        new_order_features = [0]*nvar
        for index, var in enumerate(perm):
            new_order_features[var] = ordered_features[index]
        flatten_new_order_features = [elem for lst in new_order_features
                                      for elem in lst]
        all_symmetries.append(flatten_new_order_features)
    return all_symmetries


def augmentate_timings(timings, optimal_ordering, nvar=3):
    """Given all the timings returns a list of all the possible reorderings
    so that the first reordering corresponds to the optimal ordering and
    the others follow that"""
    perms = get_perms(list(range(nvar)))
    best_variable_ordering = perms[optimal_ordering]
    new_perms = get_perms(best_variable_ordering)
    all_timings = []
    for perm in new_perms:
        # compute in which index this perm used to be
        perm_index = perms.index(perm)
        # find associated timing and append
        all_timings.append(reorder_timings(timings, perm_index, nvar=3))
    return all_timings


def reorder_timings(timings, first_ordering, nvar=3):
    """Given all the timings reorder them so that the first one
    corresponds to first_ordering and the rest from the usual
    permutations done from it"""
    perms = get_perms(list(range(nvar)))
    first_variable_ordering = perms[first_ordering]
    new_perms = get_perms(first_variable_ordering)
    new_timings = []
    for perm in new_perms:
        # compute in which index this perm used to be
        perm_index = perms.index(perm)
        # find associated timing and append
        new_timings.append(timings[perm_index])
    return new_timings
